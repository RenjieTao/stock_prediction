# -*- coding: utf-8 -*-
"""
Automatically generated by Colaboratory.
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import math
from keras.models import Sequential
from keras.layers import Dense
from keras.layers import LSTM
from keras.callbacks import ModelCheckpoint
from keras import backend as K
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import mean_squared_error
import datetime
import pandas_datareader.data as web

def singleModel(df):
  df.columns = ['Open', 'High', 'Low', 'Close', 'Adj_close', 'Volume'] # set the column names, actually same as default, just safety proof
  df.drop(['Adj_close'], inplace=True, axis=1) # Adj_close column are similar to close, thus drop this column to increase training speed
  c_names = [name for name in df.columns]

  # extract all values in dataframe to values as np.ndarray format
  values = df.values
  num_f = len(df.columns)
  
  # scale/standardize the original data for training
  scaler = MinMaxScaler(feature_range=(0,1))
  scaled = scaler.fit_transform(values)

  # hyper-parameter, use the last 15 days stock information to predict 1 day after that
  n_days_back = 15
  n_days_future = 1
  n_features = num_f

  # call function 'series_to_supervised' to format the scaled data and hyper-parameters to feed in the LSTM model
  reframed = series_to_supervised(scaled, c_names, n_days_back, n_days_future)
  n_obs = n_days_back * n_features
  target_idx = [reframed.columns.to_list().index(col) for col in reframed.columns[n_obs:] if 'Open' in col]

  # split the data into train and test sets
  values = reframed.values
  n_train_days = int(values.shape[0] * 0.75) # set 75% for training, 25% for testing
  train = values[:n_train_days, :]
  test = values[n_train_days:, :]
  train_X, train_y = train[:, :n_obs], train[:, target_idx]
  test_X, test_y = test[:, :n_obs], test[:, target_idx]

  # reshape the input to fit the LSTM model input shape/dimention
  train_X = train_X.reshape((train_X.shape[0], n_days_back, n_features))
  test_X = test_X.reshape((test_X.shape[0], n_days_back, n_features))

  # build the model
  model = Sequential()
  model.add(LSTM(150, input_shape=(train_X.shape[1], train_X.shape[2])))
  model.add(Dense(train_y.shape[1]))

  checkpoint = ModelCheckpoint('w.hdf5', monitor='val_loss', save_best_only=True)
  callback_list = [checkpoint]

  model.compile(optimizer = 'adam', loss = root_mean_squared_error)

  t = model.fit(train_X, train_y, epochs=50, batch_size=32, validation_data=(test_X, test_y), verbose=1, callbacks=callback_list, shuffle=False)

  model.load_weights('w.hdf5')

  # make prediction
  yhat = model.predict(test_X)

  # invert scaling and reshape the output back to 1-d shape
  yhat_inv_rshp = (yhat / scaler.scale_[0]).reshape((-1, 1))
  y_inv_rshp = (test_y / scaler.scale_[0]).reshape((-1, 1))

  return y_inv_rshp, yhat_inv_rshp

# preprocess data for training
def series_to_supervised(data, c_names, n_in=1, n_out=1, dropnan=True):
    n_vars = 1 if type(data) is list else data.shape[1]
   
    df = pd.DataFrame(data)
    cols, names = list(), list()
    
    # input sequence (t-n, ... t-1)
    for i in range(n_in, 0, -1):

        cols.append(df.shift(i))
        names += ['%s(t-%d)' % (n, i) for n in c_names]
    
    # forecast sequence (t, t+1, ... t+n)
    for i in range(0, n_out):
        cols.append(df.shift(-i))
        if i == 0:
            names += [('%s(t)' % n) for n in c_names]
        else:
            names += [('%s(t+%d)' % (n, i)) for n in c_names]
   
    agg = pd.concat(cols, axis=1)
    agg.columns = names
    
    if dropnan:
        agg.dropna(inplace=True)
    return agg

# function for error calculation
def root_mean_squared_error(y_true, y_pred):
  return K.sqrt(K.mean(K.square(y_pred - y_true)))

# company name of interests
company_list = ['AAPL', 'MSFT', 'GOOG', 'FB', 'AMZN', 'INTC', 'BABA']

# training for each of the company
for each in company_list:
  # scraping stock imformation from yahoo fimnance from early year till today
  start = datetime.datetime(1950,1,1)
  end = datetime.date.today()
  company_name = str(each)
  company_name = web.DataReader(each, 'yahoo', start, end) # read in as DataFrame format

  # train the LSTM model for each of the company
  company_name = singleModel(company_name) 

  # plot predicted data and real data on the test set
  plt.figure(figsize = (10,4))
  plt.title(str(each) + ': Real data vs Predicted on the Test set', fontsize=15)
  plt.plot(company_name[0], 'r', label='Real data')
  plt.plot(company_name[1], 'b', label='Predicted')
  plt.legend()
  plt.show()

